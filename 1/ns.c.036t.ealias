
;; Function printf (printf, funcdef_no=15, decl_uid=964, cgraph_uid=16, symbol_order=15)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__fmt = &PARM_NOALIAS(9)
PARM_NOALIAS(9) = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = __fmt
_4 = NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL PARM_NOALIAS(9) }
NONLOCAL = { ESCAPED NONLOCAL } same as _4
STOREDANYTHING = { }
INTEGER = { ANYTHING }
PARM_NOALIAS(9) = { ESCAPED NONLOCAL }
__fmt = { PARM_NOALIAS(9) }
__printf_chk = { }
_4 = { ESCAPED NONLOCAL }
printf = { }


Alias information for printf

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3226 } (nonlocal, escaped, restrict)

Flow-insensitive points-to information

__fmt_2(D), points-to NULL, points-to vars: { D.3226 } (nonlocal, escaped, restrict)

__attribute__((artificial, gnu_inline, always_inline))
__attribute__((nonnull (1), format (printf, 1, 2)))
int printf (const char * restrict __fmt)
{
  int _4;

  <bb 2> :
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function print_conv (print_conv, funcdef_no=40, decl_uid=3195, cgraph_uid=41, symbol_order=40)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
x = &NONLOCAL
y = &NONLOCAL
num = &NULL
_1 = x_4 + UNKNOWN
num = _1
x_19 = x_4 + UNKNOWN
k_20 = k_5 + UNKNOWN
k_20 = &NONLOCAL
x_4 = x
x_4 = x_19
k_5 = &NULL
k_5 = k_20
k_13 = k_5 + UNKNOWN
k_13 = &NONLOCAL
k_15 = k_6 + UNKNOWN
k_15 = &NONLOCAL
_3 = num
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _3
_21 = NONLOCAL
k_6 = k_13
k_6 = k_15

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _21
STOREDANYTHING = { }
INTEGER = { ANYTHING }
x = { NONLOCAL }
y = { NONLOCAL } same as x
num = { NULL NONLOCAL }
_1 = { NONLOCAL }
x_4 = { NONLOCAL }
x_19 = { NONLOCAL }
k_20 = { NULL NONLOCAL }
k_5 = { NULL NONLOCAL }
k_13 = { NULL NONLOCAL }
k_15 = { NULL NONLOCAL }
k_6 = { NULL NONLOCAL }
_3 = { NULL NONLOCAL } same as num
__printf_chk = { }
_21 = { ESCAPED NONLOCAL }


Alias information for print_conv

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information


void print_conv (unsigned int x, unsigned int y)
{
  int k;
  unsigned int num[32];
  unsigned int _1;
  unsigned int _3;
  int _21;

  <bb 2> :
  num = {};
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = x_4 % y_17(D);
  num[k_5] = _1;
  x_19 = x_4 / y_17(D);
  k_20 = k_5 + 1;

  <bb 4> :
  # x_4 = PHI <x_12(D)(2), x_19(3)>
  # k_5 = PHI <0(2), k_20(3)>
  if (x_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  k_13 = k_5 + -1;
  goto <bb 7>; [INV]

  <bb 6> :
  k_15 = k_6 + -1;
  _3 = num[k_6];
  _21 = __printf_chk (1, "%u", _3);

  <bb 7> :
  # k_6 = PHI <k_13(5), k_15(6)>
  if (k_6 >= 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  num ={v} {CLOBBER};
  return;

}



;; Function main (main, funcdef_no=39, decl_uid=3196, cgraph_uid=40, symbol_order=39)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
ESCAPED = &STRING
ESCAPED = &x
ESCAPED = &y
res_5 = NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
ESCAPED = &NONLOCAL
__PRETTY_FUNCTION__.0 = NONLOCAL
ESCAPED = &__PRETTY_FUNCTION__.0
y.0_1 = y
x.1_2 = x
ESCAPED = x.1_2
ESCAPED = y.0_1

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL x y __PRETTY_FUNCTION__.0 }
NONLOCAL = { ESCAPED NONLOCAL } same as res_5
STOREDANYTHING = { }
INTEGER = { ANYTHING }
x = { ESCAPED NONLOCAL } same as x.1_2
y = { ESCAPED NONLOCAL } same as y.0_1
__PRETTY_FUNCTION__.0 = { ESCAPED NONLOCAL }
*__isoc99_scanf = { }
res_5 = { ESCAPED NONLOCAL }
__assert_fail = { }
y.0_1 = { ESCAPED NONLOCAL }
x.1_2 = { ESCAPED NONLOCAL }
print_conv = { }
main = { }


Alias information for main

Aliased symbols

y, UID D.3199, unsigned int, is addressable
x, UID D.3198, unsigned int, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3198 D.3199 D.3201 } (nonlocal, escaped)

Flow-insensitive points-to information


int main ()
{
  static const char __PRETTY_FUNCTION__[5] = "main";
  int res;
  unsigned int y;
  unsigned int x;
  unsigned int y.0_1;
  unsigned int x.1_2;

  <bb 2> :
  res_5 = scanf ("%u%u", &x, &y);
  if (res_5 == 2)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  __assert_fail ("res==2", "ns.c", 13, &__PRETTY_FUNCTION__);

  <bb 4> :
  y.0_1 = y;
  x.1_2 = x;
  print_conv (x.1_2, y.0_1);
  x ={v} {CLOBBER};
  y ={v} {CLOBBER};
  return 0;

}


